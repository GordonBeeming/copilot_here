# GitHub Copilot Instructions for CopilotHere App

## ‚ö†Ô∏è CRITICAL: Native AOT Compatibility

**This project MUST be fully AOT (Ahead-of-Time) compatible.** Every code change must maintain AOT compatibility.

### AOT Rules - ALWAYS Follow These

1. **No Reflection-Based Serialization**
   ```csharp
   // ‚ùå WRONG - Uses reflection
   JsonSerializer.Deserialize<Config>(json);
   
   // ‚úÖ CORRECT - Use source generators
   [JsonSerializable(typeof(Config))]
   internal partial class AppJsonContext : JsonSerializerContext { }
   JsonSerializer.Deserialize(json, AppJsonContext.Default.Config);
   ```

2. **No Dynamic Types**
   ```csharp
   // ‚ùå WRONG
   dynamic obj = GetSomething();
   
   // ‚úÖ CORRECT
   var obj = GetSomething(); // Use concrete types
   ```

3. **No Runtime Code Generation**
   ```csharp
   // ‚ùå WRONG - Reflection.Emit, Expression.Compile()
   // ‚úÖ CORRECT - All code paths known at compile time
   ```

4. **All Types Must Be Known at Compile Time**
   - No `Type.GetType()` with user input
   - No `Activator.CreateInstance()` without compile-time type
   - Use interfaces and concrete implementations

5. **Source Generators for JSON**
   - Always use `System.Text.Json` source generators
   - Add `[JsonSerializable(typeof(YourType))]` for every serialized type
   - Create a `JsonSerializerContext` for all JSON operations

### Project Settings Explanation

```xml
<PublishAot>true</PublishAot>           <!-- Enable AOT compilation -->
<InvariantGlobalization>true</InvariantGlobalization>  <!-- No ICU data, smaller binary -->
<TrimMode>full</TrimMode>               <!-- Aggressive dead code elimination -->
<StackTraceSupport>false</StackTraceSupport>  <!-- Smaller binary, no stack traces -->
<OptimizationPreference>Size</OptimizationPreference>  <!-- Prefer size over speed -->
```

## Testing Requirements

**CRITICAL: All features must have tests.** Tests are in `/tests/CopilotHere.UnitTests`.

### ‚ö†Ô∏è ALWAYS Run Tests After Making Changes

**Before committing or considering work complete:**
```bash
dotnet test
```

If tests fail, fix them before proceeding. Do not leave broken tests.

### Test Framework: T-Unit

This project uses [T-Unit](https://github.com/thomhurst/TUnit) - a modern, AOT-compatible testing framework.

```csharp
// T-Unit test example
[Test]
public async Task ShouldParseArguments()
{
    var result = ParseArgs(["--dotnet"]);
    await Assert.That(result.ImageTag).IsEqualTo("dotnet");
}

// Parameterized tests
[Test]
[Arguments("-d")]
[Arguments("--dotnet")]
public async Task DotnetFlag_SetsImageTag(string flag)
{
    var result = ParseArgs([flag]);
    await Assert.That(result.ImageTag).IsEqualTo("dotnet");
}
```

### Test Categories Needed

1. **Unit Tests**
   - Argument parsing
   - Config file parsing
   - Path resolution
   - Mount path validation
   - **Alias mapping** (see `AliasTests.cs`) - CRITICAL for backwards compatibility

2. **Integration Tests**
   - Docker command generation
   - Config file reading/writing
   - Environment variable handling

### Alias Testing (Important!)

The `AliasTests.cs` file tests **every single alias** in `Program.AliasMap`. When adding new aliases:

1. Add the alias to `Program.AliasMap` in `Program.cs`
2. Add a corresponding test in `AliasTests.cs`
3. Also add the alias to the `AliasMap` copy in the test file's helper region

This ensures that:
- Short aliases (`-d`, `-d8`, `-pw`) work correctly
- PowerShell aliases (`-Dotnet`, `-Mount`, etc.) work for backwards compatibility
- Hidden aliases don't break even though they're not in help text

### Test Framework

Use T-Unit with async assertions:
```csharp
[Test]
public async Task ShouldParseArguments()
{
    var config = ParseArgs(["--mount", "/data"]);
    await Assert.That(config.ReadOnlyMounts).HasCount().EqualTo(1);
}
```

## Code Style

### Prefer Performance

```csharp
// ‚ùå WRONG - Allocates strings
var result = string.Format("Hello {0}", name);

// ‚úÖ CORRECT - Uses interpolation (compiler optimized)
var result = $"Hello {name}";

// ‚úÖ EVEN BETTER for hot paths - Use spans
ReadOnlySpan<char> span = path.AsSpan();
```

### Memory Allocation

```csharp
// ‚ùå WRONG in hot paths - Multiple allocations
var parts = path.Split('/');

// ‚úÖ CORRECT - Avoid allocations where possible
Span<Range> ranges = stackalloc Range[10];
path.AsSpan().Split(ranges, '/');
```

### Records for Data

```csharp
// ‚úÖ Use records for immutable configuration
internal record MountConfig(string HostPath, string ContainerPath, bool ReadOnly);
```

## Project Structure

```
app/
‚îú‚îÄ‚îÄ Program.cs                   # Entry point - wires up commands
‚îú‚îÄ‚îÄ Commands/                    # Vertical slices - each feature is self-contained
‚îÇ   ‚îú‚îÄ‚îÄ ICommand.cs             # Interface all commands implement
‚îÇ   ‚îú‚îÄ‚îÄ Run/                    # Main "run copilot" command
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RunCommand.cs
‚îÇ   ‚îú‚îÄ‚îÄ Mounts/                 # Mount management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _MountCommands.cs   # Main file - wires up all commands
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _MountsConfig.cs    # Config loading with merge logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ListMounts.cs       # --list-mounts handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RemoveMount.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SaveMount.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SaveMountGlobal.cs
‚îÇ   ‚îú‚îÄ‚îÄ Images/                 # Image management (same pattern)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _ImageCommands.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _ImageConfig.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ListImages.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ShowImage.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ Airlock/                # Airlock proxy (same pattern)
‚îÇ       ‚îú‚îÄ‚îÄ _AirlockCommands.cs
‚îÇ       ‚îú‚îÄ‚îÄ _AirlockConfig.cs
‚îÇ       ‚îú‚îÄ‚îÄ EnableAirlock.cs
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ Infrastructure/             # Shared primitives (stateless)
    ‚îú‚îÄ‚îÄ AppContext.cs           # Composes Paths + Environment + all Configs
    ‚îú‚îÄ‚îÄ AppPaths.cs             # Resolved file paths only
    ‚îú‚îÄ‚îÄ AppEnvironment.cs       # Runtime state (token, user IDs)
    ‚îú‚îÄ‚îÄ AirlockRunner.cs        # Airlock Docker Compose execution
    ‚îú‚îÄ‚îÄ ConfigFile.cs           # Generic config file I/O primitives
    ‚îú‚îÄ‚îÄ DockerRunner.cs         # Docker process execution
    ‚îú‚îÄ‚îÄ GitInfo.cs              # Git remote URL parsing for GitHub info
    ‚îú‚îÄ‚îÄ GitHubAuth.cs           # Token/auth handling with scope validation
    ‚îú‚îÄ‚îÄ PathValidator.cs        # Symlink resolution, sensitive path warnings
    ‚îú‚îÄ‚îÄ SelfUpdater.cs          # Version checking and update instructions
    ‚îî‚îÄ‚îÄ SystemInfo.cs           # Cross-platform utilities
```

## Command Pattern

Each feature uses partial classes to split commands into separate files.
Files prefixed with `_` are the main/config files and sort to the top.

**Main file (e.g., `_MountCommands.cs`):**
```csharp
public sealed partial class MountCommands : ICommand
{
  public void Configure(RootCommand root)
  {
    root.Add(SetListMountsCommand());
    root.Add(SetSaveMountCommand());
    // Add one line per command
  }
}
```

**Command file (e.g., `ListMounts.cs`):**
```csharp
public sealed partial class MountCommands
{
  private static Command SetListMountsCommand()
  {
    var command = new Command("--list-mounts", "Description");
    // Note: PowerShell aliases like -ListMounts are handled centrally in Program.AliasMap
    command.SetAction(_ =>
    {
      // Implementation
      return 0;
    });
    return command;
  }
}
```

**Command with argument:**
```csharp
private static Command SetSaveCommand()
{
  var command = new Command("--save", "Save something");
  // Note: PowerShell aliases like -Save are handled centrally in Program.AliasMap
  
  var pathArg = new Argument<string>("path") { Description = "Path to save" };
  command.Add(pathArg);
  
  command.SetAction(parseResult =>
  {
    var path = parseResult.GetValue(pathArg)!;
    // Use path
    return 0;
  });
  return command;
}
```

**Adding a new command:**
1. Copy an existing command file (e.g., `ListMounts.cs`)
2. Rename file and method (`SetXxxCommand`)
3. Add one line to the main file: `root.Add(SetXxxCommand());`
4. Add PowerShell alias to `Program.AliasMap` if needed for backwards compatibility

## System.CommandLine 2.0.0 Notes

This project uses System.CommandLine 2.0.0 GA which has significant API changes from betas:

- `AddCommand()` ‚Üí `Add()`
- `AddOption()` ‚Üí `Add()`
- `AddArgument()` ‚Üí `Add()`
- `AddAlias()` ‚Üí `Aliases.Add()`
- `SetHandler()` ‚Üí `SetAction(parseResult => { ... return 0; })`
- Option constructor: `new Option<T>("--name") { Description = "..." }`
- Argument constructor: `new Argument<T>("name") { Description = "..." }`
- Getting values: `parseResult.GetValue(option)`

## Configuration Architecture

Each feature owns its config loading with its own merge/priority logic:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      AppContext.Create()                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  AppPaths.Resolve()      ‚Üí CurrentDir, UserHome, ConfigPaths‚îÇ
‚îÇ  AppEnvironment.Resolve() ‚Üí GitHubToken, UserId, GroupId    ‚îÇ
‚îÇ  ImageConfig.Load()       ‚Üí Tag from local > global > default‚îÇ
‚îÇ  MountsConfig.Load()      ‚Üí Additive: global + local mounts ‚îÇ
‚îÇ  AirlockConfig.Load()     ‚Üí Enabled flag, rules path        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
            CLI args override config values in handler
```

**Config Priority Patterns:**
- **Override (Image):** CLI > Local > Global > Default
- **Additive (Mounts):** Global + Local + CLI (all combined)
- **Flag (Airlock):** Local flag > Global flag

## Feature Implementation Checklist

When implementing a new feature:

1. [ ] Check if feature uses reflection ‚Üí If yes, find AOT alternative
2. [ ] Check if feature requires JSON ‚Üí Add source generator attributes
3. [ ] Add unit tests for the feature
4. [ ] Add integration tests if it interacts with external systems
5. [ ] **Run `dotnet test` to verify all tests pass**
6. [ ] Test with `dotnet publish -c Release` (will fail if not AOT compatible)

### After ANY Code Changes

Always run tests before considering work complete:
```bash
dotnet test
```
6. [ ] Update `/docs/migration-to-native-binary.md` status

## Common Patterns

### Security Validation

All security checks must prompt for user confirmation when encountering sensitive conditions:

```csharp
// Token scope validation (GitHubAuth.cs)
var (isValid, error) = GitHubAuth.ValidateScopes();
if (!isValid)
{
    Console.WriteLine($"‚ùå {error}");
    return 1;
}

// Sensitive path validation (PathValidator.cs)
if (!PathValidator.ValidateSensitivePath(resolvedPath, userHome))
{
    Console.WriteLine("‚è≠Ô∏è  Skipping mount: {path}");
    continue; // User cancelled
}

// Symlink following
var resolved = PathValidator.ResolvePath(path, userHome);
// This will print "üîó Following symlink: X ‚Üí Y" if symlink
```

**Sensitive paths that require confirmation:**
- `/` (root)
- `/etc` and subdirectories
- `/root` and subdirectories
- `~/.ssh` and subdirectories

**Token scopes that require confirmation:**
- `admin:*` (admin:org, admin:enterprise, etc.)
- `manage_*`
- `write:public_key`
- `delete_repo`
- `write_packages`
- `delete_packages`

### Config File Reading (AOT-Safe)

```csharp
[JsonSerializable(typeof(NetworkConfig))]
[JsonSerializable(typeof(MountsConfig))]
internal partial class ConfigJsonContext : JsonSerializerContext { }

public static NetworkConfig? LoadNetworkConfig(string path)
{
    if (!File.Exists(path)) return null;
    var json = File.ReadAllText(path);
    return JsonSerializer.Deserialize(json, ConfigJsonContext.Default.NetworkConfig);
}
```

### Environment Variables

```csharp
// ‚úÖ CORRECT - Direct access
var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
var token = Environment.GetEnvironmentVariable("GITHUB_TOKEN");
```

### Process Execution

```csharp
// ‚úÖ CORRECT - Use ProcessStartInfo with ArgumentList
var startInfo = new ProcessStartInfo
{
    FileName = "docker",
    UseShellExecute = false
};
startInfo.ArgumentList.Add("run");
startInfo.ArgumentList.Add("--rm");
```

## Dependencies

Only use AOT-compatible packages:
- `System.CommandLine` (2.0.0) ‚úÖ - Argument parsing
- `System.Text.Json` ‚úÖ - JSON (with source generators)

**DO NOT ADD** packages that require reflection:
- Newtonsoft.Json ‚ùå
- AutoMapper ‚ùå
- Any DI container without AOT support ‚ùå

## Build Verification

Always verify AOT compatibility:

```bash
# This will fail if code is not AOT compatible
dotnet publish -c Release -r linux-x64

# Test on multiple platforms
dotnet publish -c Release -r win-x64
dotnet publish -c Release -r osx-arm64
```

## Migration Reference

See `/docs/migration-to-native-binary.md` for:
- Complete feature checklist from shell scripts
- Status of each feature implementation
- Config file locations
- Architecture notes
