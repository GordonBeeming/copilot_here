# GitHub Copilot Instructions for CopilotHere App

## ⚠️ CRITICAL: Native AOT Compatibility

**This project MUST be fully AOT (Ahead-of-Time) compatible.** Every code change must maintain AOT compatibility.

### AOT Rules - ALWAYS Follow These

1. **No Reflection-Based Serialization**
   ```csharp
   // ❌ WRONG - Uses reflection
   JsonSerializer.Deserialize<Config>(json);
   
   // ✅ CORRECT - Use source generators
   [JsonSerializable(typeof(Config))]
   internal partial class AppJsonContext : JsonSerializerContext { }
   JsonSerializer.Deserialize(json, AppJsonContext.Default.Config);
   ```

2. **No Dynamic Types**
   ```csharp
   // ❌ WRONG
   dynamic obj = GetSomething();
   
   // ✅ CORRECT
   var obj = GetSomething(); // Use concrete types
   ```

3. **No Runtime Code Generation**
   ```csharp
   // ❌ WRONG - Reflection.Emit, Expression.Compile()
   // ✅ CORRECT - All code paths known at compile time
   ```

4. **All Types Must Be Known at Compile Time**
   - No `Type.GetType()` with user input
   - No `Activator.CreateInstance()` without compile-time type
   - Use interfaces and concrete implementations

5. **Source Generators for JSON**
   - Always use `System.Text.Json` source generators
   - Add `[JsonSerializable(typeof(YourType))]` for every serialized type
   - Create a `JsonSerializerContext` for all JSON operations

### Project Settings Explanation

```xml
<PublishAot>true</PublishAot>           <!-- Enable AOT compilation -->
<InvariantGlobalization>true</InvariantGlobalization>  <!-- No ICU data, smaller binary -->
<TrimMode>full</TrimMode>               <!-- Aggressive dead code elimination -->
<StackTraceSupport>false</StackTraceSupport>  <!-- Smaller binary, no stack traces -->
<OptimizationPreference>Size</OptimizationPreference>  <!-- Prefer size over speed -->
```

## Testing Requirements

**CRITICAL: All features must have tests.** Tests are in `/tests/CopilotHere.UnitTests`.

### ⚠️ ALWAYS Run Tests After Making Changes

**Before committing or considering work complete:**
```bash
dotnet test
```

If tests fail, fix them before proceeding. Do not leave broken tests.

### Test Framework: T-Unit

This project uses [T-Unit](https://github.com/thomhurst/TUnit) - a modern, AOT-compatible testing framework.

```csharp
// T-Unit test example
[Test]
public async Task ShouldParseArguments()
{
    var result = ParseArgs(["--dotnet"]);
    await Assert.That(result.ImageTag).IsEqualTo("dotnet");
}

// Parameterized tests
[Test]
[Arguments("-d")]
[Arguments("--dotnet")]
public async Task DotnetFlag_SetsImageTag(string flag)
{
    var result = ParseArgs([flag]);
    await Assert.That(result.ImageTag).IsEqualTo("dotnet");
}
```

### Test Categories Needed

1. **Unit Tests**
   - Argument parsing
   - Config file parsing
   - Path resolution
   - Mount path validation

2. **Integration Tests**
   - Docker command generation
   - Config file reading/writing
   - Environment variable handling

### Test Framework

Use T-Unit with async assertions:
```csharp
[Test]
public async Task ShouldParseArguments()
{
    var config = ParseArgs(["--mount", "/data"]);
    await Assert.That(config.ReadOnlyMounts).HasCount().EqualTo(1);
}
```

## Code Style

### Prefer Performance

```csharp
// ❌ WRONG - Allocates strings
var result = string.Format("Hello {0}", name);

// ✅ CORRECT - Uses interpolation (compiler optimized)
var result = $"Hello {name}";

// ✅ EVEN BETTER for hot paths - Use spans
ReadOnlySpan<char> span = path.AsSpan();
```

### Memory Allocation

```csharp
// ❌ WRONG in hot paths - Multiple allocations
var parts = path.Split('/');

// ✅ CORRECT - Avoid allocations where possible
Span<Range> ranges = stackalloc Range[10];
path.AsSpan().Split(ranges, '/');
```

### Records for Data

```csharp
// ✅ Use records for immutable configuration
internal record MountConfig(string HostPath, string ContainerPath, bool ReadOnly);
```

## Project Structure

```
app/
├── Program.cs                   # Entry point - wires up commands
├── Commands/                    # Vertical slices - each feature is self-contained
│   ├── ICommand.cs             # Interface all commands implement
│   ├── Run/                    # Main "run copilot" command
│   │   └── RunCommand.cs
│   ├── Mounts/                 # Mount management
│   │   ├── _MountCommands.cs   # Main file - wires up all commands
│   │   ├── _MountsConfig.cs    # Config loading with merge logic
│   │   ├── ListMounts.cs       # --list-mounts handler
│   │   ├── RemoveMount.cs
│   │   ├── SaveMount.cs
│   │   └── SaveMountGlobal.cs
│   ├── Images/                 # Image management (same pattern)
│   │   ├── _ImageCommands.cs
│   │   ├── _ImageConfig.cs
│   │   ├── ListImages.cs
│   │   ├── ShowImage.cs
│   │   └── ...
│   └── Airlock/                # Airlock proxy (same pattern)
│       ├── _AirlockCommands.cs
│       ├── _AirlockConfig.cs
│       ├── EnableAirlock.cs
│       └── ...
└── Infrastructure/             # Shared primitives (stateless)
    ├── AppContext.cs           # Composes Paths + Environment + all Configs
    ├── AppPaths.cs             # Resolved file paths only
    ├── AppEnvironment.cs       # Runtime state (token, user IDs)
    ├── ConfigFile.cs           # Generic config file I/O primitives
    ├── DockerRunner.cs         # Docker process execution
    ├── GitHubAuth.cs           # Token/auth handling
    └── SystemInfo.cs           # Cross-platform utilities
```

## Command Pattern

Each feature uses partial classes to split commands into separate files.
Files prefixed with `_` are the main/config files and sort to the top.

**Main file (e.g., `_MountCommands.cs`):**
```csharp
public sealed partial class MountCommands : ICommand
{
  public void Configure(RootCommand root)
  {
    root.Add(SetListMountsCommand());
    root.Add(SetSaveMountCommand());
    // Add one line per command
  }
}
```

**Command file (e.g., `ListMounts.cs`):**
```csharp
public sealed partial class MountCommands
{
  private static Command SetListMountsCommand()
  {
    var command = new Command("--list-mounts", "Description");
    command.Aliases.Add("-ListMounts");
    command.SetAction(_ =>
    {
      // Implementation
      return 0;
    });
    return command;
  }
}
```

**Command with argument:**
```csharp
private static Command SetSaveCommand()
{
  var command = new Command("--save", "Save something");
  command.Aliases.Add("-Save");
  
  var pathArg = new Argument<string>("path") { Description = "Path to save" };
  command.Add(pathArg);
  
  command.SetAction(parseResult =>
  {
    var path = parseResult.GetValue(pathArg)!;
    // Use path
    return 0;
  });
  return command;
}
```

**Adding a new command:**
1. Copy an existing command file (e.g., `ListMounts.cs`)
2. Rename file and method (`SetXxxCommand`)
3. Add one line to the main file: `root.Add(SetXxxCommand());`

## System.CommandLine 2.0.0 Notes

This project uses System.CommandLine 2.0.0 GA which has significant API changes from betas:

- `AddCommand()` → `Add()`
- `AddOption()` → `Add()`
- `AddArgument()` → `Add()`
- `AddAlias()` → `Aliases.Add()`
- `SetHandler()` → `SetAction(parseResult => { ... return 0; })`
- Option constructor: `new Option<T>("--name") { Description = "..." }`
- Argument constructor: `new Argument<T>("name") { Description = "..." }`
- Getting values: `parseResult.GetValue(option)`

## Configuration Architecture

Each feature owns its config loading with its own merge/priority logic:

```
┌─────────────────────────────────────────────────────────────┐
│                      AppContext.Create()                     │
├─────────────────────────────────────────────────────────────┤
│  AppPaths.Resolve()      → CurrentDir, UserHome, ConfigPaths│
│  AppEnvironment.Resolve() → GitHubToken, UserId, GroupId    │
│  ImageConfig.Load()       → Tag from local > global > default│
│  MountsConfig.Load()      → Additive: global + local mounts │
│  AirlockConfig.Load()     → Enabled flag, rules path        │
└─────────────────────────────────────────────────────────────┘
                              ↓
            CLI args override config values in handler
```

**Config Priority Patterns:**
- **Override (Image):** CLI > Local > Global > Default
- **Additive (Mounts):** Global + Local + CLI (all combined)
- **Flag (Airlock):** Local flag > Global flag

## Feature Implementation Checklist

When implementing a new feature:

1. [ ] Check if feature uses reflection → If yes, find AOT alternative
2. [ ] Check if feature requires JSON → Add source generator attributes
3. [ ] Add unit tests for the feature
4. [ ] Add integration tests if it interacts with external systems
5. [ ] **Run `dotnet test` to verify all tests pass**
6. [ ] Test with `dotnet publish -c Release` (will fail if not AOT compatible)

### After ANY Code Changes

Always run tests before considering work complete:
```bash
dotnet test
```
6. [ ] Update `/docs/migration-to-native-binary.md` status

## Common Patterns

### Config File Reading (AOT-Safe)

```csharp
[JsonSerializable(typeof(NetworkConfig))]
[JsonSerializable(typeof(MountsConfig))]
internal partial class ConfigJsonContext : JsonSerializerContext { }

public static NetworkConfig? LoadNetworkConfig(string path)
{
    if (!File.Exists(path)) return null;
    var json = File.ReadAllText(path);
    return JsonSerializer.Deserialize(json, ConfigJsonContext.Default.NetworkConfig);
}
```

### Environment Variables

```csharp
// ✅ CORRECT - Direct access
var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
var token = Environment.GetEnvironmentVariable("GITHUB_TOKEN");
```

### Process Execution

```csharp
// ✅ CORRECT - Use ProcessStartInfo with ArgumentList
var startInfo = new ProcessStartInfo
{
    FileName = "docker",
    UseShellExecute = false
};
startInfo.ArgumentList.Add("run");
startInfo.ArgumentList.Add("--rm");
```

## Dependencies

Only use AOT-compatible packages:
- `System.CommandLine` (2.0.0) ✅ - Argument parsing
- `System.Text.Json` ✅ - JSON (with source generators)

**DO NOT ADD** packages that require reflection:
- Newtonsoft.Json ❌
- AutoMapper ❌
- Any DI container without AOT support ❌

## Build Verification

Always verify AOT compatibility:

```bash
# This will fail if code is not AOT compatible
dotnet publish -c Release -r linux-x64

# Test on multiple platforms
dotnet publish -c Release -r win-x64
dotnet publish -c Release -r osx-arm64
```

## Migration Reference

See `/docs/migration-to-native-binary.md` for:
- Complete feature checklist from shell scripts
- Status of each feature implementation
- Config file locations
- Architecture notes
