# GitHub Copilot Instructions for CopilotHere App

## ⚠️ CRITICAL: Native AOT Compatibility

**This project MUST be fully AOT (Ahead-of-Time) compatible.** Every code change must maintain AOT compatibility.

### AOT Rules - ALWAYS Follow These

1. **No Reflection-Based Serialization**
   ```csharp
   // ❌ WRONG - Uses reflection
   JsonSerializer.Deserialize<Config>(json);
   
   // ✅ CORRECT - Use source generators
   [JsonSerializable(typeof(Config))]
   internal partial class AppJsonContext : JsonSerializerContext { }
   JsonSerializer.Deserialize(json, AppJsonContext.Default.Config);
   ```

2. **No Dynamic Types**
   ```csharp
   // ❌ WRONG
   dynamic obj = GetSomething();
   
   // ✅ CORRECT
   var obj = GetSomething(); // Use concrete types
   ```

3. **No Runtime Code Generation**
   ```csharp
   // ❌ WRONG - Reflection.Emit, Expression.Compile()
   // ✅ CORRECT - All code paths known at compile time
   ```

4. **All Types Must Be Known at Compile Time**
   - No `Type.GetType()` with user input
   - No `Activator.CreateInstance()` without compile-time type
   - Use interfaces and concrete implementations

5. **Source Generators for JSON**
   - Always use `System.Text.Json` source generators
   - Add `[JsonSerializable(typeof(YourType))]` for every serialized type
   - Create a `JsonSerializerContext` for all JSON operations

### Project Settings Explanation

```xml
<PublishAot>true</PublishAot>           <!-- Enable AOT compilation -->
<InvariantGlobalization>true</InvariantGlobalization>  <!-- No ICU data, smaller binary -->
<TrimMode>full</TrimMode>               <!-- Aggressive dead code elimination -->
<StackTraceSupport>false</StackTraceSupport>  <!-- Smaller binary, no stack traces -->
<OptimizationPreference>Size</OptimizationPreference>  <!-- Prefer size over speed -->
```

## Testing Requirements

**CRITICAL: All features must have tests.** Tests are in `/tests/CopilotHere.Tests`.

### Test Framework: T-Unit

This project uses [T-Unit](https://github.com/thomhurst/TUnit) - a modern, AOT-compatible testing framework.

```csharp
// T-Unit test example
[Test]
public async Task ShouldParseArguments()
{
    var result = ParseArgs(["--dotnet"]);
    await Assert.That(result.ImageTag).IsEqualTo("dotnet");
}

// Parameterized tests
[Test]
[Arguments("-d")]
[Arguments("--dotnet")]
public async Task DotnetFlag_SetsImageTag(string flag)
{
    var result = ParseArgs([flag]);
    await Assert.That(result.ImageTag).IsEqualTo("dotnet");
}
```

### Test Categories Needed

1. **Unit Tests**
   - Argument parsing
   - Config file parsing
   - Path resolution
   - Mount path validation

2. **Integration Tests**
   - Docker command generation
   - Config file reading/writing
   - Environment variable handling

### Test Framework

Use T-Unit with async assertions:
```csharp
[Test]
public async Task ShouldParseArguments()
{
    var config = ParseArgs(["--mount", "/data"]);
    await Assert.That(config.ReadOnlyMounts).HasCount().EqualTo(1);
}
```

## Code Style

### Prefer Performance

```csharp
// ❌ WRONG - Allocates strings
var result = string.Format("Hello {0}", name);

// ✅ CORRECT - Uses interpolation (compiler optimized)
var result = $"Hello {name}";

// ✅ EVEN BETTER for hot paths - Use spans
ReadOnlySpan<char> span = path.AsSpan();
```

### Memory Allocation

```csharp
// ❌ WRONG in hot paths - Multiple allocations
var parts = path.Split('/');

// ✅ CORRECT - Avoid allocations where possible
Span<Range> ranges = stackalloc Range[10];
path.AsSpan().Split(ranges, '/');
```

### Records for Data

```csharp
// ✅ Use records for immutable configuration
internal record MountConfig(string HostPath, string ContainerPath, bool ReadOnly);
```

## Project Structure

```
app/
├── CopilotHere.csproj      # Main project file
├── Models/                  # Data models
│   └── RunConfig.cs        # Configuration record
├── Orchestration/          # Core logic
│   ├── Program.cs          # Entry point
│   └── AirlockComposer.cs  # Docker Compose generation
├── Config/                  # Add config loading here
├── Security/               # Add security checks here
└── Utils/                  # Add utilities here
```

## Feature Implementation Checklist

When implementing a new feature:

1. [ ] Check if feature uses reflection → If yes, find AOT alternative
2. [ ] Check if feature requires JSON → Add source generator attributes
3. [ ] Add unit tests for the feature
4. [ ] Add integration tests if it interacts with external systems
5. [ ] Test with `dotnet publish -c Release` (will fail if not AOT compatible)
6. [ ] Update `/docs/migration-to-native-binary.md` status

## Common Patterns

### Config File Reading (AOT-Safe)

```csharp
[JsonSerializable(typeof(NetworkConfig))]
[JsonSerializable(typeof(MountsConfig))]
internal partial class ConfigJsonContext : JsonSerializerContext { }

public static NetworkConfig? LoadNetworkConfig(string path)
{
    if (!File.Exists(path)) return null;
    var json = File.ReadAllText(path);
    return JsonSerializer.Deserialize(json, ConfigJsonContext.Default.NetworkConfig);
}
```

### Environment Variables

```csharp
// ✅ CORRECT - Direct access
var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
var token = Environment.GetEnvironmentVariable("GITHUB_TOKEN");
```

### Process Execution

```csharp
// ✅ CORRECT - Use ProcessStartInfo with ArgumentList
var startInfo = new ProcessStartInfo
{
    FileName = "docker",
    UseShellExecute = false
};
startInfo.ArgumentList.Add("run");
startInfo.ArgumentList.Add("--rm");
```

## Dependencies

Only use AOT-compatible packages:
- `System.CommandLine` (2.0.0) ✅ - Argument parsing
- `System.Text.Json` ✅ - JSON (with source generators)

**DO NOT ADD** packages that require reflection:
- Newtonsoft.Json ❌
- AutoMapper ❌
- Any DI container without AOT support ❌

## Build Verification

Always verify AOT compatibility:

```bash
# This will fail if code is not AOT compatible
dotnet publish -c Release -r linux-x64

# Test on multiple platforms
dotnet publish -c Release -r win-x64
dotnet publish -c Release -r osx-arm64
```

## Migration Reference

See `/docs/migration-to-native-binary.md` for:
- Complete feature checklist from shell scripts
- Status of each feature implementation
- Config file locations
- Architecture notes
