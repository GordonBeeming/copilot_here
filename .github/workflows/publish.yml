# This workflow builds and publishes the Docker image.
# Tests run first on all triggers. Publishing only happens on main branch.
name: Build and Publish Docker Images

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  schedule:
    # Runs nightly at 3:15 AM UTC to check for npm package updates.
    - cron: "15 3 * * *"
  workflow_dispatch: # Allows the workflow to be run manually from the Actions tab

# Sets the minimum required permissions for the entire workflow for security.
permissions:
  contents: read
  packages: write

jobs:
  # Run tests first - required for all triggers
  test-bash-zsh:
    name: Test Bash/Zsh on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install PowerShell (for cross-platform testing)
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            # Install PowerShell on Ubuntu
            sudo apt-get update
            sudo apt-get install -y wget apt-transport-https software-properties-common
            wget -q "https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb"
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update
            sudo apt-get install -y powershell
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            # Install PowerShell on macOS
            brew install --cask powershell
          fi
      
      - name: Make test scripts executable
        run: chmod +x tests/run_all_tests.sh tests/integration/*.sh
        
      - name: Run all integration tests
        run: ./tests/run_all_tests.sh

  test-windows:
    name: Test PowerShell on Windows
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Run PowerShell integration tests
        shell: pwsh
        run: |
          pwsh tests/run_all_tests.ps1

  build-and-publish:
    name: Build and Publish Images
    needs: [test-bash-zsh, test-windows]  # Tests must pass before building/publishing
    runs-on: ubuntu-latest
    # Only publish on main branch push, schedule, or manual dispatch
    # PRs will run tests but not publish
    if: github.event_name != 'pull_request'
    steps:
      # Step 1: Check out the repository's code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set lowercase repository name for Docker
      - name: Set lowercase repository name
        id: repo
        run: echo "name=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      # Step 3: Set up QEMU for multi-platform builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Step 4: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 5: Log in to the GitHub Container Registry (GHCR)
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 6: Extract metadata (tags, labels) for Docker
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            # Add 'latest' tag for pushes to the main branch
            type=raw,value=latest,enable={{is_default_branch}}
            # Add tag for the git branch name (e.g., 'main')
            type=ref,event=branch
            # Add tag for the git commit SHA
            type=sha

      # Step 7: Get latest versions for dependencies
      - name: Get latest dependency versions
        id: versions
        run: |
          # Copilot CLI
          COPILOT_VERSION=$(npm view @github/copilot version)
          echo "copilot_version=$COPILOT_VERSION" >> $GITHUB_OUTPUT
          echo "Latest Copilot CLI version: $COPILOT_VERSION"

          # Playwright
          PLAYWRIGHT_VERSION=$(npm view playwright version)
          echo "playwright_version=$PLAYWRIGHT_VERSION" >> $GITHUB_OUTPUT
          echo "Latest Playwright version: $PLAYWRIGHT_VERSION"
          
          # .NET 8
          DOTNET_8_VERSION=$(curl -s https://dotnetcli.blob.core.windows.net/dotnet/release-metadata/8.0/releases.json | jq -r '."latest-sdk"')
          echo "dotnet_8_version=$DOTNET_8_VERSION" >> $GITHUB_OUTPUT
          echo "Latest .NET 8 SDK version: $DOTNET_8_VERSION"
          
          # .NET 9
          DOTNET_9_VERSION=$(curl -s https://dotnetcli.blob.core.windows.net/dotnet/release-metadata/9.0/releases.json | jq -r '."latest-sdk"')
          echo "dotnet_9_version=$DOTNET_9_VERSION" >> $GITHUB_OUTPUT
          echo "Latest .NET 9 SDK version: $DOTNET_9_VERSION"
          
          # .NET 10
          DOTNET_10_VERSION=$(curl -s https://dotnetcli.blob.core.windows.net/dotnet/release-metadata/10.0/releases.json | jq -r '."latest-sdk"')
          echo "dotnet_10_version=$DOTNET_10_VERSION" >> $GITHUB_OUTPUT
          echo "Latest .NET 10 SDK version: $DOTNET_10_VERSION"

      # Step 8: Get the digest of the currently published 'latest' image
      # This step only runs on scheduled or manual triggers, not on push events.
      - name: Get digest of the remote 'latest' image
        if: github.event_name != 'push'
        id: remote_digest
        run: |
          # Try to get the digest of the remote image, handle case when it doesn't exist
          DIGEST=$(docker manifest inspect ghcr.io/${{ steps.repo.outputs.name }}:latest 2>/dev/null | jq -r '.config.digest' || echo "")
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Remote digest: $DIGEST"

      # Step 9: Build the image and check for changes
      # This step builds the image locally and tags it, making it ready for a potential push.
      # It uses the remote 'latest' image as a cache source and passes the Copilot version as a build arg.
      # The version arg ensures cache invalidation when a new Copilot version is released.
      - name: Build image and get its new digest
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.base
          platforms: linux/amd64,linux/arm64
          push: false # We don't push yet; we decide that in the next step.
          load: false # Can't load multi-platform images
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            ${{ steps.meta.outputs.labels }}
            project=copilot_here
          build-args: |
            COPILOT_VERSION=${{ steps.versions.outputs.copilot_version }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:latest,mode=max
          cache-to: type=inline
          outputs: type=image,push=false

      # Step 10: Decide if a push is required based on the trigger and image changes
      - name: Determine if a push is required
        id: push_decision
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "Decision: Pushing new image due to a commit on the main branch."
            echo "push_needed=true" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.build.outputs.digest }}" != "${{ steps.remote_digest.outputs.digest }}" ]]; then
            echo "Decision: New image digest (${{ steps.build.outputs.digest }}) differs from remote digest (${{ steps.remote_digest.outputs.digest }}). Pushing update."
            echo "push_needed=true" >> $GITHUB_OUTPUT
          else
            echo "Decision: Image is already up-to-date. No push required."
            echo "push_needed=false" >> $GITHUB_OUTPUT
          fi

      # Step 11: Push the base image to registry only if needed
      - name: Push base image to registry
        if: steps.push_decision.outputs.push_needed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.base
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ steps.repo.outputs.name }}:latest
            ghcr.io/${{ steps.repo.outputs.name }}:sha-${{ github.sha }}
          labels: |
            ${{ steps.meta.outputs.labels }}
            project=copilot_here
          build-args: |
            COPILOT_VERSION=${{ steps.versions.outputs.copilot_version }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:latest,mode=max
          cache-to: type=inline

      # Step 11a: Extract metadata for Proxy image
      - name: Extract metadata for Proxy image
        id: meta-proxy
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=proxy
            type=raw,value=proxy-sha-${{ github.sha }}

      # Step 11b: Build and push Proxy image (Rust-based network proxy for Airlock mode)
      - name: Build and push Proxy image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.proxy
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-proxy.outputs.tags }}
          labels: |
            ${{ steps.meta-proxy.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:proxy,mode=max
          cache-to: type=inline

      # Step 12: Extract metadata for .NET image
      - name: Extract metadata for .NET image
        id: meta-dotnet
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=dotnet
            type=raw,value=dotnet-sha-${{ github.sha }}

      # Step 13: Build and push .NET image (based on the base image)
      - name: Build and push .NET image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/variants/Dockerfile.dotnet
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=sha-${{ github.sha }}
            DOTNET_SDK_8_VERSION=${{ steps.versions.outputs.dotnet_8_version }}
            DOTNET_SDK_9_VERSION=${{ steps.versions.outputs.dotnet_9_version }}
            DOTNET_SDK_10_VERSION=${{ steps.versions.outputs.dotnet_10_version }}
          tags: ${{ steps.meta-dotnet.outputs.tags }}
          labels: |
            ${{ steps.meta-dotnet.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:dotnet,mode=max
          cache-to: type=inline

      # Step 13a: Extract metadata for .NET 8 image
      - name: Extract metadata for .NET 8 image
        id: meta-dotnet8
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=dotnet-8
            type=raw,value=dotnet-8-sha-${{ github.sha }}

      # Step 13b: Build and push .NET 8 image
      - name: Build and push .NET 8 image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/variants/Dockerfile.dotnet8
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=sha-${{ github.sha }}
            DOTNET_SDK_8_VERSION=${{ steps.versions.outputs.dotnet_8_version }}
          tags: ${{ steps.meta-dotnet8.outputs.tags }}
          labels: |
            ${{ steps.meta-dotnet8.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:dotnet-8,mode=max
          cache-to: type=inline

      # Step 13c: Extract metadata for .NET 9 image
      - name: Extract metadata for .NET 9 image
        id: meta-dotnet9
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=dotnet-9
            type=raw,value=dotnet-9-sha-${{ github.sha }}

      # Step 13d: Build and push .NET 9 image
      - name: Build and push .NET 9 image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/variants/Dockerfile.dotnet9
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=sha-${{ github.sha }}
            DOTNET_SDK_9_VERSION=${{ steps.versions.outputs.dotnet_9_version }}
          tags: ${{ steps.meta-dotnet9.outputs.tags }}
          labels: |
            ${{ steps.meta-dotnet9.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:dotnet-9,mode=max
          cache-to: type=inline

      # Step 13e: Extract metadata for .NET 10 image
      - name: Extract metadata for .NET 10 image
        id: meta-dotnet10
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=dotnet-10
            type=raw,value=dotnet-10-sha-${{ github.sha }}

      # Step 13f: Build and push .NET 10 image
      - name: Build and push .NET 10 image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/variants/Dockerfile.dotnet10
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=sha-${{ github.sha }}
            DOTNET_SDK_10_VERSION=${{ steps.versions.outputs.dotnet_10_version }}
          tags: ${{ steps.meta-dotnet10.outputs.tags }}
          labels: |
            ${{ steps.meta-dotnet10.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:dotnet-10,mode=max
          cache-to: type=inline

      # Step 14: Extract metadata for Playwright+.NET image
      - name: Extract metadata for Playwright+.NET image
        id: meta-playwright
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=dotnet-playwright
            type=raw,value=dotnet-playwright-sha-${{ github.sha }}

      # Step 15: Build and push Playwright+.NET image (based on the .NET image)
      - name: Build and push Playwright+.NET image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/variants/Dockerfile.dotnet-playwright
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            DOTNET_IMAGE_TAG=dotnet-sha-${{ github.sha }}
            PLAYWRIGHT_VERSION=${{ steps.versions.outputs.playwright_version }}
          tags: ${{ steps.meta-playwright.outputs.tags }}
          labels: |
            ${{ steps.meta-playwright.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:dotnet-playwright,mode=max
          cache-to: type=inline

      # Step 16: Extract metadata for Playwright image
      - name: Extract metadata for Playwright image
        id: meta-playwright-base
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo.outputs.name }}
          tags: |
            type=raw,value=playwright
            type=raw,value=playwright-sha-${{ github.sha }}

      # Step 17: Build and push Playwright image (based on the base image)
      - name: Build and push Playwright image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/variants/Dockerfile.playwright
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=sha-${{ github.sha }}
            PLAYWRIGHT_VERSION=${{ steps.versions.outputs.playwright_version }}
          tags: ${{ steps.meta-playwright-base.outputs.tags }}
          labels: |
            ${{ steps.meta-playwright-base.outputs.labels }}
            project=copilot_here
          cache-from: type=registry,ref=ghcr.io/${{ steps.repo.outputs.name }}:playwright,mode=max
          cache-to: type=inline

      # Step 18: Provide a clear summary message for scheduled runs when no update was needed
      - name: Print summary for scheduled run
        if: github.event_name == 'schedule' && steps.push_decision.outputs.push_needed == 'false'
        run: echo "☑️ No new version of the npm package found. The published image is already up-to-date."

      # Step 17: Summary of workflow behavior
      - name: Workflow Summary
        if: always()
        run: |
          echo "## Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tests:** ✅ Passed (required before build)" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.push_decision.outputs.push_needed }}" == "true" ]]; then
            echo "**Images Published:**" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:proxy\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:dotnet\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:dotnet-8\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:dotnet-9\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:dotnet-10\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:dotnet-playwright\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`ghcr.io/${{ steps.repo.outputs.name }}:playwright\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Images:** No changes, skipped publishing" >> $GITHUB_STEP_SUMMARY
          fi
